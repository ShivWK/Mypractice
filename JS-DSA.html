<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body> 
    <script>
        //to check whether given string is palindrome or not 
    //    let str = prompt("Give your string: ");
    //    let len = str.length;
       
    //    function comp(n){
    //     if(n >= len/2){
    //         console.log("string is palindrome");
    //         return true;
    //     }else{
    //         if(str[n].toLowerCase() === str[len-n-1].toLowerCase()){
    //             comp(n+1);
    //         }else{
    //             console.log("Not a palindrome");
    //             return false;
    //         }
    //     }
    //    }
    //    comp(0);

    //to print nth fibonacci number not counting startiong 0 in the series

    // let term = parseInt(prompt("Your term: "),10);
    // console.log(fiboterm(term));
    // function fiboterm(n){
    //     if(n <=1){
    //         return n;
    //     }else{
    //         let last = fiboterm(n-1);
    //         let slast = fiboterm(n-2);
    //         return last + slast;
    //     }
    // }
       
//hashing, counting how many times a particular number have been appered in the array
    // function countArray(){
    //     //prompt returns string
    //     let size = parseInt(prompt("Enter the size of the array "));
    //     let arr = new Array(size);
    //     for(let i=0; i<size; i++){
    //         arr[i] = parseInt(prompt(`Give ${i+1} number `));
    //     }

        //size should be large enugh so because item in arr is index in has, so if arr has size 5 but elements are [1,15,44,50] so 50 index should be present in has array so give size to has as the max value in arr + 1, 1 is for 0 index; because if 12 then index would be 0 to 11 but we want 0 to 12;

    //     let has = new Array(Math.max(...arr) + 1).fill(0);

    //     for(let i=0; i<size; i++){
    //         has[arr[i]] += 1;
    //     }
    //     let q = parseInt(prompt("How many query "));
    //     while(q--){
    //         let num = parseInt(prompt("Your query "));
    //         console.log(has[num]);
    //     }        
    // }
    // countArray();

    // // function frequencyCount(arr,N,P){    
    // //     let has = new Array(P + 1).fill(0);
    // //     for(let i=0; i<has.length; i++){ 
    // //         if(arr.includes(i)){
    // //             has[i] += 1;
    // //         }                     
    // //     }
    // //     return has;
    // // }   
    // console.log(frequencyCount([1,2,1,1,3], 5, 3)); 
    
    //Selection sort
        // function selectionSort(arr){
        //     const n = arr.length;

        //     for(let i=0; i<=n-2; i++){
        //         let minIndex = i;
        //         for(let j=i+1; j<=n-1; j++){
        //             if(arr[j]<arr[minIndex])
        //             {
        //                 minIndex=j;
        //             }
        //         }
        //         let temp = arr[i];
        //         arr[i] = arr[minIndex];
        //         arr[minIndex] = temp;
        //     }
        //     for(let i=0; i<n; i++){
        //         console.log(arr[i]+" ");
        //     }

        // }
        
        // selectionSort([11,9,50,85,15,3,0]);

        //Bubble sort
        
        // function bubbleSort(arr){
        //     const n = arr.length;
        //     let swapped = false;
        //     for(let i=n-1; i>=n-(n-1); i--){
        //         // let minIndex = i;
        //         for(let j=0; j<=i-1; j++){
        //             if(arr[j] > arr[j+1])
        //             {
        //                 let temp = arr[j];
        //                 arr[j] = arr[j+1];
        //                 arr[j+1] = temp;

        //                 swapped = true;
        //             }
        //         }
        //         if(!swapped){
        //             break;
        //         }
        //     }
        //     for(let i=0; i<n; i++){
        //         console.log(arr[i]+" ");
        //     }

        // }
        
        // // bubbleSort([11,9,50,85,15,3,0]);
        // bubbleSort([1,2,3,5,8,9])

        //insertion sort
        // function insertionSort(arr){
        //     const n = arr.length;
         
        //     for(let i=0; i<=n-1; i++){
        //         let j = i;
        //         while(j>0 && arr[j-1]>arr[j]){
        //                 let temp = arr[j-1];
        //                 arr[j-1] = arr[j];
        //                 arr[j] = temp;

        //                 j--;
        //         }
        //     }
        //     for(let i=0; i<n; i++){
        //         console.log(arr[i]+" ");
        //     }
        // }
        // insertionSort([11,9,50,85,15,3,0]);
        // bubbleSort([1,2,3,5,8,9])

        //merge sort 
        // function merge(arr, low, mid, high){
        //     let temp = [];
        //     let left = low;
        //     let right = mid + 1;
        //     let i = 0;
        //     while(left <= mid && right <= high){
        //         if(arr[left] <= arr[right]){
        //             temp[i] = arr[left];
        //             i++;
        //             left++;
        //         }else{
        //             temp[i] = arr[right];
        //             i++;
        //             right++;
        //         }
        //     }
        //     while(left <= mid){
        //         temp[i] = arr[left];
        //         i++;
        //         left++;
        //     }
        //     while(right <= high){
        //         temp[i] = arr[right];
        //         i++;
        //         right++;
        //     }

        //     for(let i=0; i<temp.length; i++){
        //         arr[low + i] = temp[i];
        //     }

        //     //mean if low is point to other index not 0 like 2 then we should replace the elements from index 2 in original array, this can be in case we have array like [1,2,4,9,6,12,80] then here I will point low to 2 .

        //     // The concept behind using low + i is to ensure that the merged elements are placed back into their correct positions in the original array. This is particularly important when you're merging subarrays that do not start at index 0.
          
        // }

        // function mergeSort(arr){
        //     const n = arr.length;
        //     let low = 0;
        //     let high = n-1;
        //     ms(arr, low, high);
        //     function ms(arr, low, high){
        //         if(low >= high) return;
        //         let mid = Math.floor((low + high) / 2);
        //         ms(arr, low, mid);
        //         ms(arr, mid+1, high);

        //         merge(arr, low, mid, high);
        //     }   
        //     for(let i=0; i<arr.length; i++){
        //         console.log(arr[i]);
        //     }        

        // }
        // // mergeSort([11,9,50,85,15,3,0]);
        // mergeSort([1,2,3,5,8,9])

        //quick sort problem
        function partition(arr, low, high){
            let pivot = arr[low];
            let i = low;
            let j = high;
            while(i < j){
                while(arr[i] <= pivot && i <= high -1){
                    i++;
                }
                while(arr[j] > pivot && j >= low +1 ){
                    j--;
                }
                if(i < j){
                    let temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            let temp = arr[j];
            arr[j] = pivot;
            arr[low] = temp;
            return j;
        }

        function quickSort(arr, low = 0, high = arr.length-1){
            if(low < high){
                let indexOfPivot = partition(arr, low, high);
                quickSort(arr, low, indexOfPivot -1);
                quickSort(arr, indexOfPivot + 1, high);
            }
           return arr; 
        }

        console.log(quickSort([11,9,50,85,15,3,0]));
    </script>
</body>
</html> 