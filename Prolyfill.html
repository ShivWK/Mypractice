<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>Prolyfill</h1>
    <script>
        // the Array.prototype.myForEach method is defined as a property on the Array prototype, which does not benefit from hoisting in the same way as function declarations. So, myForEach wont be hoisted here

//forEach Prolyfill

        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        let obj = [
            { id: 1, name: 'Shivendra' },
            { id: 2, name: 'Shiv' },
            { id: 3, name: 'Sahil' },
            { id: 4, name: 'Ritik' }
        ]
        // function callback(vl, index, self){
        //     console.log(vl);
        //     console.log(index+" index");
        // }

        // Array.prototype.myForEach = function(cb){
        //     if(!cb){
        //         throw new Error('undefined is not a function')
        //     }
        //     for(let i=0; i<this.length; i++){
        //         cb(this[i], i, this);
        //     }
        // }
        // arr.myForEach(callback);

//map Prolyfill

        // Array.prototype.myMap = function(cb){
        //     if(!cb) throw new Error("undefined is not a function");

        //     let newArray = [];

        //     for(let i=0; i<this.length; i++){
        //         const result = cb(this[i], i, this);
        //         newArray.push(result);
        //     }
        //     return newArray;
        // }

        // const result = arr.myMap(value => value * 3)
        // console.log(result)

//filter function prolyfill

        //      Array.prototype.myFilter = function(cb){
        //         if(!cb) throw new Error("undefined is not a function");
        //         const newArray = [];

        //         for(let i=0; i<this.length; i++){
        //             const result = cb(this[i], i, this);
        //             if(result) newArray.push(this[i]);
        //         }
        //         return newArray;
        //     }

        //     const result = arr.myFilter(value => value < 3)
        //     console.log(result)

//FIND FUNCTION Prolyfill

        // Array.prototype.myFind = function(cd){
        //     if(!cd) throw new Error("undefined is not a function");

        //     for (let i=0; i<this.length; i++){
        //         const result = cd(this[i], i, this);
        //         if(result) return arr2[i];
        //     }
        //     return undefined;
        // }

        // console.log(arr2.myFind((e)=>e == 3))

//Some function Prolyfill

        let arr2 = [1, -2];

        //  Array.prototype.mySome = function(cd){
        //         if(!cd) throw new Error("undefined is not a function");

        //         for (let i=0; i<this.length; i++){
        //             const result = cd(this[i], i, this);

        //             if(result) return true;
        //         }
        //         return false;
        //     }
        //  console.log(arr2.mySome((e)=> e<0) )

//every function prolyfill

        // Array.prototype.myEvery = function(cd){
        //         if(!cd) throw new Error("undefined is not a function");

        //         for (let i=0; i<this.length; i++){
        //             const result = cd(this[i], i, this);

        //             if(!result) return false;
        //         }
        //         return true;
        //     }
        // console.log(arr2.myEvery((e)=> e>0) )

//reduce function prolyfill

        // const user = [
        //     { firstName: "shiv", age: 25 },
        //     { firstName: "shivendra", age: 25 },
        //     { firstName: "shivshena", age: 26 },
        //     { firstName: "sahil", age: 27 },
        //     { firstName: "Shiva ji", age: 35 },
        // ]

        // Array.prototype.myReduce = function (callback, initialValue) {
        //     if (typeof callback !== 'function') throw new Error('undefined is not a function');

        //     let accumulator = initialValue;
        //     let startIndex = 0;

        //     if(accumulator === undefined){
        //         if(this.length === 0){
        //             throw new TypeError("reduce of empty array with no initial values")
        //         }
        //         accumulator = this[0];
        //         startIndex = 1
        //     }

        //     for (let i = startIndex; i < this.length; i++) {
        //        accumulator = callback(accumulator, this[i], i, this);     
        //     }
        //     return accumulator;
        // }

        // const outputq = user.myReduce(function (acc, curr) {
        //     if (curr.age > 25) {
        //         acc.push(curr.firstName);
        //     }
        //     return acc;
        // }, [])
        // console.log(outputq)

//call() polyfill

        // persion = {
        //     name: "shivendra"
        // }

        // persion2 = {
        //     name: "sahil"
        // }

        // function foo(age, profession) {
        //     console.log(`hi I'm ${this.name} and my age is ${age} and i'm a ${profession}`);
        // }

        // foo.call(24);
        // foo.call(persion2);

        // Function.prototype.myCall = function (context, ...args) {
        //     if (typeof this !== 'function') {
        //         throw new Error(this + " is not a callable function");
        //     }

        //     if (context == null) {
        //         context = globalThis;
        //     } else {
        //         context = Object(context);
        //     }

        //     const uniqueId = Symbol('reffunc');

        //     context[uniqueId] = this;

        //     const result = context[uniqueId](...args);

        //     delete context[uniqueId];

        //     return result;

        // }
        // let re = foo.myCall();
        // console.log(re)
        // foo.myCall(persion2);

//apply function polyfill


//          Function.prototype.myApply = function(context, args){
//             if(!typeof this === 'function') throw new Error(`${this} is not a callable function`);

//             context = context || globalTHis;

//             args = args || [];

//             let uniqueID = Symbol('refunc');
            
//             context[uniqueID] = this;

//             const result = context[uniqueID](...args);

//             delete context[uniqueID];

//             return result;
//         }
        
//         foo.myApply( [25, "web developer"])
        
//         foo.apply([25, "web developer"])
        
//flat() polyfill

        // Array.prototype.myFlat = function(depth = 1) {
        //     // Ensure depth is a number and defaults to 1
        //     depth = isNaN(depth) ? 1 : Number(depth);

        //     const flatten = (arr, depth) => {
        //     return arr.reduce((acc, val) => {
        //         // If the value is an array and depth is greater than 0, recursively flatten
        //         if (Array.isArray(val) && depth > 0) {
        //         acc.push(...flatten(val, depth - 1));
        //         } else {
        //         acc.push(val);
        //         }
        //         return acc;
        //     }, []);
        //     };

        //     return flatten(this, depth);
        // };

        // arr = [1,2,[3,4,[5,6,[7,8,[9]]]]] 
        // console.log(arr.myFlat(Infinity));

//Promise() Polyfill

        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                // resolve("Promise 1 resolved");
                reject("Promise 1 rejected");
            }, 3000);    

        })

        const p2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject("Promise 2 rejected");
                // resolve("P/romise 2 resolved");
            }, 1000);    

        })

        const p3 = new Promise((resolve, reject) => {
            setTimeout(() => {
                // resolve("Promise 3 resolved");
                reject("Promise 3 resolved");
            }, 2000);    

        })

//Promise

        // const Promise = function(executer) {
        //         this.then(callback) {
        //                 return this;
        //         }

        //         this.catch(callback) {
        //                 return this;
        //         }

        //         executer()
        // }

Promise.all()

        Promise.myAll = function (promises) {
                return new Promise((resolve, reject) => {
                        let n = promises.length;
                        let result = [];
                        let promiseCount = 0;
                        if (!Array.isArray(promises)) {
                               reject(new Error("myAll: undefined is not an iterable")) 
                                        return          
                        }                    
                        if (n === 0) {
                               resolve([]);
                                        return 
                        }
                        promises.forEach((promise, index) =>  {
                                
                                promise
                                .then(response => {
                                        result[index] = response;
                                        promiseCount++

                                        if (promiseCount === n) {
                                               resolve(result)
                                                return 
                                        }
                                }).catch(error => {
                                       reject(error);
                                        return 
                                })
                        })
                })
        }
        
        const newPro1 = Promise.myAll([p1,p2,p3]);
        newPro1.then(data => {
            console.log(data);
        }).catch(err => {
            console.error(err);
        })
        console.log(newPro1);

        //even if resolve or reject is called further code in the promise executer function will continue to execute so stop the  further code execution We have used return to return the control then n there

//Polyfill of Promise.allSettled()
         
        Promise.myallSettled = function (promises) {
                return new Promise((resolve, reject) => {
                        if (!Array.isArray(promises)) {
                               reject(new Error("myallsettled: undefined is not an iterable"))          
                                return 
                        }                       
                        let n = promises.length;
                        let results = [];
                        let promiseCount = 0;
        
                        if (n === 0) {
                               resolve(results);
                                        return 
                        }
                        promises.forEach((promise, index) =>  {
                                
                                promise
                                .then(response => {
                                        results[index] = {status : "fulfilled" , value : response};
                                        promiseCount++;

                                        if (promiseCount === n) {
                                               resolve(results)
                                               return ;
                                        }

                                }).catch(error => {
                                        results[index] = {status : "rejected" , reason : error};
                                        promiseCount++;

                                        if (promiseCount === n) {
                                               resolve(results)
                                                return 
                                        }
                                })
                        })
                })
        }
        const newPro2 = Promise.myallSettled([p1, p2, p3]);
        newPro.then(data => {
            console.log(data);
        }).catch(err => {
            console.error(err);
        })
        console.log(newPro);

//Promise.race()

        Promise.myRace = function (promises) {
                return new Promise((resolve, reject) => {
                        let n = promises.length;

                        if (!Array.isArray(promises)) {
                                reject(new Error("myRace: undefined is not an iterable"));
                                return;    
                        } 
                        
                        if (n === 0) {
                                resolve();
                                return;
                        }

                        promises.forEach((promise, index) =>  {
                                
                              Promise.resolve(promise)
                                .then(response => resolve(response))
                                .catch(error => reject(error))
                        })
                })
        }

        const newPro3 = Promise.myRace([p1, p2, p3]);
        newPro.then(data => {
            console.log(data);
        }).catch(err => {
            console.error(err);
        })
        console.log(newPro);

//Promise.any() 

        Promise.myAny = function (promises) {
                return new Promise((resolve, reject) => {
                        let n = promises.length;

                        if (!Array.isArray(promises)) {
                                reject(new Error("myAny: undefined is not an iterable"));
                                return;    
                        } 
                        
                        if (n === 0) {
                                reject(new Error("AggregateError: All promises were rejected"));
                                return;
                        }

                        promises.forEach((promise, index) =>  {
                                
                              Promise.resolve(promise)
                                .then(response => resolve(response))
                                .catch(error => reject(error))
                        })
                })
        }

        const newPro4 = Promise.any([]);
        newPro.then(data => {
            console.log(data);
        }).catch(err => {
            console.error(err);
        })
        // console.log(newPro);

        // const newPro2 = Promise.myAny([]);
        // newPro2.then(data => {
        //     console.log(data);
        // }).catch(err => {
        //     console.error(err);
        // })
        // console.log(newPro2);

//Promise.any() Polyfill

        // Promise.myAny1 = function(promises) {
        //         return new Promise((resolve, reject) => {
        //         if (!Array.isArray(promises)) {
        //                 reject(new TypeError("Argument must be an iterable"));
        //                 return;
        //         }

        //         let rejectionCount = 0;
        //         let errors = [];

        //         if (promises.length === 0) {
        //                 reject(new AggregateError([], "All promises were rejected"));
        //                 return;
        //         }
        //         promises.forEach((promise, index) => {
        //                 Promise.resolve(promise)
        //                 .then(resolve)  // If any promise fulfills, resolve immediately
        //                 .catch(error => {
        //                         errors[index] = error;
        //                         rejectionCount++;
        //                         if (rejectionCount === promises.length) {
                
        //                                 reject(new AggregateError(errors, "All promises were rejected"));
        //                         }
        //                 });
        //         });
        //         });
        // };

        // Promise.myAny = function(promises) {
        //         return new Promise((resolve, reject) => {
        //                 if(!Array.isArray(promises)) {
        //                         reject(new TypeError("undefined is not iterable"));
        //                         return;
        //                 }

        //                 let n = promises.length;
        //                 let errors = [];
        //                 let failedCounter = 0;

        //                 if(n === 0) {
        //                         reject(new AggregateError(errors, "All promises were rejected"));
        //                         return;
        //                 }

        //                 promises.forEach((promise, index) => {
        //                         Promise.resolve(promise)
        //                         .then(resolve)
        //                         .catch(err => {
        //                               errors[index] = err;
        //                                 failedCounter++;

        //                                 if (failedCounter === n) {
        //                                         reject(new AggregateError(errors, "All promises were rejected"))
        //                                 }
        //                         })
        //                 })

        //         })
        // }

        // const newPro2 = Promise.myAny([p1,p2,p3]);
        // newPro2.then(data => {
        //     console.log(data);
        // }).catch(err => {
        //         console.log(err);
        //     console.error(err.errors);
        // })

       
//JS interview questions

        // let name = "shiv";
        // age = 23;
        // console.log(delete name);
        // console.log(delete age);

        // for (var i = 0; i<10; i++){
        //     setTimeout(()=>{
        //         console.log(i);
        //     },0)
        // }

        // when used var
        // global
        // ---------------------------------------
        // i=10
        // setTimeout() --1
        // setTimeout() --2
        // setTimeout() --3
        // setTimeout() --4
        // setTimeout() --5
        // setTimeout() --6
        // setTimeout() --7
        // setTimeout() --8
        // setTimeout() --9
        // setTimeout() --10
        // ---------------------------------------

        // when used let 
        // block scope
        // ---------------------------------------
        // i =0;
        // setTimeout() --1
        // ---------------------------------------
        // i =1;
        // setTimeout() --2
        // ---------------------------------------
        // i =2;
        // setTimeout() --3th
        // ---------------------------------------
        // i =3;
        // setTimeout() --4th
        // ---------------------------------------
        // i =4;
        // setTimeout() --5
        // ---------------------------------------
        // i =5;
        // setTimeout() --6
        // ---------------------------------------
        // i =6;
        // setTimeout() --1
        // ---------------------------------------
        // i =7;
        // setTimeout() --1
        // ---------------------------------------
        // i =8;
        // setTimeout() --1
        // ---------------------------------------
        // i =9;
        // setTimeout() --1
        // ---------------------------------------
    </script>

</body>

</html>