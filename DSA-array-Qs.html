<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        //Second Largest

        // function secondLargest(arr){
        //     let max = arr[0],
        //      secondMax = -1; //assuming array doesn't have element lesser than -1;

        //     for(let i=0; i<arr.length; i++){
        //         if(arr[i] > max){
        //             secondMax = max;
        //             max = arr[i];
        //         }
        //         else if(arr[i] > secondMax && arr[i] < max){
        //             secondMax = arr[i];
        //         }
        //     }
        //     return [max, secondMax];
        // }

        // console.log(secondLargest([1,2]));

        //Second Smallest

        // function secondSmallest(arr){
        //     let small = arr[0],
        //      secondsmall = Infinity; //assuming array doesn't have element lesser than -1;

        //     for(let i=0; i<arr.length; i++){
        //         if(arr[i] < small){
        //             secondsmall = small;
        //             small = arr[i];
        //         }
        //         else if(arr[i] > small && arr[i] < secondsmall){
        //             secondsmall = arr[i];
        //         }
        //     }
        //     return [small, secondsmall];
        // }

        // console.log(secondSmallest([1,2,9,15,0,-2,-5]));

        //Array is sorted or not for non decending mean array will in increasing if sorted

        // function sorted(arr){
        //     for(let i = 1; i<arr.length; i++){
        //         if(arr[i] >= arr[i-1]){
        //             return "sorted";
        //         }else{
        //             return "not sorted";
        //         }
        //     }     
        // }
        // console.log(sorted([1,2,3,4]));
        // console.log(sorted([4,3,2,1]));

//for both kind increasing and decreasing

        //     function sorted(arr){

        //         if(arr.length <= 1) return "sorted as Increasing";
        //         let decreasing = increasing = false;

        //         for(let i = 1; i<arr.length; i++){
        //             if(arr[i] <= arr[i-1]){
        //                 decreasing =  true;
        //             }else if (arr[i] >= arr[i-1]){
        //                 increasing = true;
        //             }               
        //         }
        //         if(decreasing) return "sorted as deceresing"  ;
        //         if(increasing) return "sorted as increasing"  ;
        //         return 'not sorted'; 
        //     }
        //     console.log(sorted([1,2,3,4]));
        //    console.log(sorted([4,3,2,1]));
        //    console.log(sorted([1]));

        //REmove dublicates from the given array

        //Not efficient
        // function remover(arr){
        //     const mySet = new Set(arr);

        //         arr=[...mySet]

        //     return arr;
        // }
        // console.log(remover([1,1,2,2,3,3,4,5,4]))

    //Efficient one by set data structure
        // function remover(arr){
        //     const mySet = new Set(arr);
        //     let i = 0;
        //     for(const value of mySet){
        //         arr[i]=value;
        //         i++
        //     } 
        //     arr.length = i;       
        //     return i;
        // }
        // let num = [1,1,2,2,3,4,3]
        // let index = remover(num);
        // console.log("New length of the array "+index)
        // console.log("new array is "+ num);


    //optimal for sorted arrays 
        //     function removeDuplicates(nums) {
        //     if (nums.length === 0) return 0;

        //     let i = 0;
        //     for (let j = 1; j < nums.length; j++) {
        //         if (nums[j] !== nums[i]) {
        //             i++;
        //             nums[i] = nums[j];
        //         }
        //     }
        //     return i + 1;
        // }
        // let nums = [1, 1, 2, 2, 3, 4, 4];
        // let newLength = removeDuplicates(nums);
        // console.log("New length:", newLength);
        // console.log("Array after removing duplicates:", nums.slice(0, newLength));

//Left Rotate an array by one place

        //1 functional approach
        // function rotate(arr){
        //     const firstElement = arr.shift();
        //     arr.push(firstElement);
        //     return arr;

        // }

        // console.log(rotate([1,2,1,5,8,9,10]));

        //2 genuin approach

        // function rotate(arr){
        //     const firstElement = arr[0];
        //     for(let i = 1; i< arr.length; i++ ){
        //         arr[i-1] = arr[i];
        //     }
        //     arr[arr.length-1] = firstElement;
        //     return arr;
        // }
        // console.log(rotate([1,2,3,4,5,6]));

//rotation for n number of places

        // function rotate(arr, n){

        //     if(arr.length === 0) return arr; 
        //     let arrLength = arr.length;
        //     const initialValue = [];

        //     for(let i=0; i<n; i++){
        //         initialValue[i]=arr[i];
        //     }

        //     for(let i= n; i<arrLength; i++){
        //         arr[i-n] = arr[i];
        //     }
        //     //let j=0
        //     for(let i=arrLength - n; i<arrLength; i++){
        //         arr[i] = initialValue[i - (arrLength-n)];
        //         //j++;
        //     }

        //     return arr;
        // }
        // console.log(rotate([1, 2, 3, 4, 5, 6, 7], 2));

        //optimal solution for rotation left by n  places

        // function reverseArray(arr, start, end) {
        //     while (start < end) {
        //         [arr[start], arr[end]] = [arr[end], arr[start]];
        //         start++;
        //         end--;
        //     }
        // }

        // function leftRotateByN(arr, n) {
        //     const len = arr.length;
        //     if (len === 0) return arr;

        //     // Normalize the number of rotations
        //     n = n % len;
        //     if (n === 0) return arr;

        //     // Step 1: Reverse the first n elements
        //     reverseArray(arr, 0, n - 1);

        //     // Step 2: Reverse the remaining elements
        //     reverseArray(arr, n, len - 1);

        //     // Step 3: Reverse the entire array
        //     reverseArray(arr, 0, len - 1);

        //     return arr;
        // }

// Example usage
        // const arr = [1, 2, 3, 4, 5];
        // const n = 3;
        // console.log(leftRotateByN(arr, n)); // Output: [4, 5, 1, 2, 3]

        //Put all zeros to the end of the array

    //Brute Force
        // function ZeroReversal(arr){
        //     let len = arr.length;
        //     if(len <= 1) return arr;
        //     let tempArr =[];

        //     for(let i = 0; i<len; i++){
        //         if(arr[i] !== 0){
        //             tempArr.push(arr[i]);
        //         }
        //     }
        //     for(let i=0; i<tempArr.length; i++){
        //         arr[i]=tempArr[i];
        //     }
        //     for(let i=tempArr.length; i<len; i++){
        //         arr[i] = 0;
        //     }
        //     return arr;

        // }
        // console.log(ZeroReversal([1,0,2,3,2,0,0,4,5,1]));

    //Optimal Solution
        // function ZeroReversal(arr){
        //     let len = arr.length;
        //     if(len <= 1) return arr;
        //     let j = -1;
        //     for(let i=0; i<len; i++){
        //         if(arr[i] === 0){
        //             j=i;
        //             break;
        //         }
        //     }

        //     if(j == -1) return arr;

        //     for(let i = j+1; i<len; i++ ){
        //         if(arr[i] !== 0){
        //             // let temp = arr[j];
        //             arr[j] = arr[i];
        //             arr[i] = 0;
        //             j++
        //         }
        //     }

        //     return arr;
        // } 
        // console.log(ZeroReversal([0,2,3,2,0,0,4,5,1]));

        //Linear search in an array telling occurence index of an element

        // function iterate(arr, n){
        //     for(let i= 0; i<arr.length; i++){
        //         if(arr[i] === n){
        //             return i;
        //         }
        //      return -1;
        //     }
        // }
        // console.log(iterate([1,5,8,3,7,10,12,55,9], 0))

//Union of two arrays

    //Brute force Dont pass all test cases
        // function union(arr1 , arr2){
        //     if(arr1.length == 0 && arr2.length ==0) return arr1;
        //     let mySet = new Set();
        //     for(let i=0; i<arr1.length; i++){
        //         mySet.add(arr1[i]);
        //     }
        //     for(let i=0; i<arr2.length; i++){
        //         mySet.add(arr2[i]);
        //     }

        //     let i =0;
        //     let newArray = [];
        //     for (let values of mySet){
        //         newArray[i] = values;
        //         i++;
        //     }
        //     return newArray;
        // }
        // console.log(union([1,2,2,3,3,4,5,6], [1,2,3,3,4,5,8,9]));
    
    //Optimal

        // function Union(arr1, arr2) {
        //     let len1 = arr1.length;
        //     let len2 = arr2.length;
        //     if (len1 == 0 && len2 == 0) return arr1;
        //     let newArray = [];
        //     let i = j = 0;

        //     while (i < len1 && j < len2) {
        //         if (arr1[i] <= arr2[j]) {
        //             if (newArray.length == 0 || newArray[newArray.length - 1] !== arr1[i]) {
        //                 //dont use pop() to get last element for checking whether it maches or not use newArray[len -1] because newArray.pop() will take that element out forever and you will lose that element 
        //                 newArray.push(arr1[i]);
        //             }
        //             i++;
        //         } else {
        //             if (newArray.length == 0 || newArray[newArray.length - 1] !== arr2[j]) {
        //                 newArray.push(arr2[j]);
        //             }
        //             j++;
        //         }
        //     }
        //     while (j < len2) {
        //         if (newArray.length == 0 || newArray[newArray.length - 1] !== arr2[j]) {
        //             newArray.push(arr2[j]);
        //         }
        //         j++;
        //     }
        //     while (i < len1) {
        //         if (newArray.length == 0 || newArray[newArray.length - 1] !== arr1[i]) {
        //             newArray.push(arr1[i]);
        //         }
        //         i++;
        //     }
        //     return newArray;
        // }
        // console.log(Union([1, 2, 2, 3, 3, 4, 5, 6], [1, 2, 3, 3, 4, 5, 8, 9]));

//Intersection of two Array

    //brute force
        
        // function Intersection(arr1, arr2) {
        //     //repeatation is allowed
        //         let len1 = arr1.length;
        //         let len2 = arr2.length;
        //         if (len1 == 0 && len2 == 0) return arr1;
        //         let newArray = [];
        //         let visitedArray = new Array(len2);
        //         visitedArray.fill(0);

        //         for(let i =0; i<len1; i++){
        //             for(let j =0; j<len2; j++){
        //                 if(arr1[i] == arr2[j] && visitedArray[j] !== 1){
        //                     newArray.push(arr1[i]);
        //                     visitedArray[j] = 1;
        //                     break;
        //                 }
        //                 if(arr2[j] > arr1[i]) break;
        //             }
        //         }

        //         return newArray;
        //     }
        // console.log(Intersection([1, 2, 2, 3, 3, 4, 5, 6], [1, 2, 3, 3, 4, 5, 8, 9]));

    //optimal solution    
        // function Intersection(arr1, arr2){
        
        //     if (arr1.length == 0 ) return arr2;
        //     else if(arr2.length == 0) return arr1;
        //     let i = 0 , j = 0;
        //     let newArray = [];
        //     while(i<arr1.length && j<arr2.length){
        //         if(arr1[i] < arr2[j]){
        //             i++;
        //         }
        //         else if(arr2[j] < arr1[i]){
        //             j++;
        //         }else{
        //             newArray.push(arr1[i]);
        //             i++;
        //             j++;
        //         }
                
        //     }
        //     return newArray;
        // }
        // console.log(Intersection([1, 2, 2, 3, 3, 4, 5, 6], [1, 2, 3, 3, 4, 5, 8, 9]));

//Find Missing element

    //Brute Force
    // function Missing(arr, n){
    //     for(let i = 1; i<= n; i++){
    //         let flag = 0;

    //         for(let j =0; j<arr.length; j++){
    //             if(arr[j] === i){
    //                 flag = 1;
    //                 //we will break here because we have got what we are searching no need to gibeyond
    //                 break;
    //             }
    //         }
    //         if(flag === 0){
    //             return i;
    //         }
    //     }
    // }

    //Better approach
        // function Missing(arr, n){
        //     let hash = new Array(n+1).fill(0);

        //     for(let i = 0; i<arr.length; i++){
        //         hash[arr[i]] = 1;
        //     }
        //     for(let i = 1; i<hash.length; i++){
        //         if(hash[i] === 0){
        //             return i;
        //         }
        //     }

        // }

    //optimal 1 Sum

    // function Missing(arr, n){
    //     let sum1 = n*(n + 1)/2, sum2 = 0;

    //     for(let i = 0; i<arr.length; i++){
    //             sum2 += arr[i];
    //     }
    //     return (sum1 - sum2);

    // }

    //optimal 2 XOR

        //function Missing(arr, n){
        //  let xor1 = 0, xor2 = 0;

        //  for(let i = 1; i<=n; i++ ){
        //       xor1 ^= i;
        //  }

        //  for(let i = 0; i<n-1; i++){
        //        xor2 ^= arr[i];
        //    }
        //        return (xor1 ^ xor2);

        //  }

        //  console.log(Missing([1,2,3,4,6,7],7))

//maximum consecutive numbers of n

        // function maxOccurance(arr, n){
        //     let counter = 0;
        //     let maxNumber = 0;

        //     for(let i = 0; i<arr.length; i++){
        //         if(arr[i] == n){
        //             counter++;
        //             maxNumber = Math.max(maxNumber, counter);
        //         }else{
        //             counter = 0;
        //         }
        //     }
        //     return maxNumber;
        // }
        // console.log(maxOccurance([1,1,2,3,5,5,5,5,6,7,5,5], 5));

//Finding which number isn't repeated in an array

    //Brute Force
        // function finding(arr){
            
        //     for(let i= 0; i<arr.length; i++){
        //         let counter =0;
        //         for(let j = 0; j<arr.length; j++){
        //             if(arr[j]=== i){
        //                 counter++;
        //             }
        //         }
        //         if(counter === 1) return i;
        //     }
        // }

        // console.log(finding([1,1,5,5,5,5,6,6,0,5,5]));

    //Better Solution 1
        
        // function finding(arr){
        //     let max = 0;
        //     for(let i=0; i<arr.length; i++){
        //         max = Math.max(max, arr[i]);
        //     }

        //     let hash = new Array(max+1).fill(0);

        //     for(let i=0; i<arr.length; i++){
        //         hash[arr[i]]++;
        //     }
        //     for(let i=0; i<arr.length; i++){
        //         if(hash[arr[i]]===1) return arr[i];
        //     }
        //     return -1;
        // }
        // console.log(finding([1,1,5,5,5,3,5,6,6,5,5]));

    //Better solution 2

        //  function finding(arr){
        //     let myMap = new Map();

        //     for(let i =0; i<arr.length; i++){
        //         if(myMap.get(arr[i])){
        //             myMap.set(arr[i], myMap.get(arr[i]) +1)
        //         }else{
        //             myMap.set(arr[i], 1)
        //         }
        //     }
        //     for(let [key,value] of myMap){
        //         if(value === 1){
        //             return key;
        //         }
        //     }
        //     return -1;
        //  }
        //  console.log(finding([1,1,5,5,5,5,6,5,5]));

    //Optimal Solution 

        // function finding(arr){
        //     let xor =0;
        //     for(let i=0; i<arr.length; i++){
        //         xor ^= arr[i];
        //     }
        //     return xor;
        // }
        // console.log(finding([1,1,5,5,5,5,6,5,5]));

//Logest subArray with k sum

    // //Brute force
    //     function LongestSubA(arr, n){
    //         let len = 0;
    //         for(let i =0; i<arr.length; i++){
                
    //             for(let j =i; j<arr.length; j++){
    //                 let sum = 0;
    //                 for(let k; k<=j; k++){
    //                     sum += arr[k];
    //                 }       
    //                 if(sum === n) {
    //                     len = Math.max(len, j-i+1);
    //                 }
    //             }
    //         }
    //         return len;
    //     }
    //     console.log(LongestSubA([1,1,2,3,4,4,5,6,6], 3))

    // //Better solution
    //     function LongestSubA(arr, n){
    //         let len = 0;
    //         for(let i =0; i<arr.length; i++){
    //             let sum = 0;
    //             for(let j =i; j<arr.length; j++){
    //                 sum += arr[j];
                    
    //                 if(sum === n) {
    //                     len = Math.max(len, j-i+1);
    //                 }
    //             }
    //         }
    //         return len;
    //     }
    //     console.log(LongestSubA([1,1,2,3,4,4,5,6,6], 3))

    //optimal Solution for array having 0, +ve, -ve, Better for array having only +ve, no 0, no -ve

        // function LongestSubA(arr, n){
        //     let map = new Map();
        //     let sum = 0;
        //     let maxLen = 0;
        //      let count = 0;

        //     for(let i=0; i<arr.length; i++){
        //         sum += arr[i];

        //         if(sum == n){
        //             maxLen = Math.max(maxLen, i+1);
        //         }

        //         if(!map.has(sum)){
        //             map.set(sum, i );
        //         }

        //         let rem = sum - n;

        //         if(map.has(rem)){
        //             let len = i - map.get(rem);
        //             maxLen = Math.max(maxLen, len);
        //              count++;
        //         }
        //     }
        //     return maxLen;       
        //  }
        //  console.log(LongestSubA([1,0,2,0,-4,4,5,6,6],4 ))

    //Optimal for having only +ve, 0
    
    //     function LongestSubA(arr, n){
    //         let left = 0, right = 0;
    //         let maxLen = 0;
    //         let sum = arr[0];
    //         let len = arr.length;

    //         while(right < len){

                
    //             while(sum > n && left <= right){
    //                 sum -= arr[left];
    //                 left++;
    //             }
    //             if(sum == n){
    //                 maxLen = Math.max(maxLen, right - left + 1)
    //             }

    //             right++;
    //             if(right < len) sum += arr[right];

    //         }
    //         return maxLen;
    //     }
    //     console.log(LongestSubA([1,0,2,0,4,5,6,6],2))

//2SUM problem

    //Brute force

        // function TwoSum(arr, k){
        //     // let len = arr.length;

        //     for(let i =0; i<arr.length; i++){
                
        //         for(let j = i + 1; j<arr.length; j++){

        //             //if(i == j) or i + 1 continue; //because we are not adding one element with itself

        //             if(arr[i] + arr[j] === k){
        //                 return [i,j];
        //             }
        //         }        
        //     }
        //     return "NO";
        // }
        //console.log(TwoSum([1,2,5,4,7,3,9], 9));

    //Better solution for case whuch wants elements or yes/no in return and optimal for index return

        // function TwoSum(arr, k){
        //     let map = new Map();
        //     for(let i=0; i<arr.length; i++){
        //         let rem = k - arr[i];
        //         if(map.has(rem)){
        //             // return "yes";
        //             let rem_index = map.get(rem)
        //             // return [arr[i], arr[rem_index]]
        //             return [i, rem_index]

        //         }          
        //         map.set(arr[i], i);
        //     }
        //     return "no"
        // }
        // console.log(TwoSum([1,2,5,4,7,3,9], 10));

    //Optimal Solution for case whuch wants elements or yes/no in return and it is not for index return because when we have sorted the array ideces changed

        // function TwoSum(arr , k){
        //    const shortedArray = arr.sort();
        //     let i =0;
        //     let j =arr.length - 1;

        //     while(i<j){
        //         if(arr[i] + arr[j] == k){
        //             return "yes"
        //         }
        //         else if(arr[i] + arr[j] < k) i++;
        //         else j--;
                
        //     }
        //     return "no"

        // }
        // console.log(TwoSum([1,2,5,4,7,3,9], 8));

//sorting array having 0s,1s,2s

    //brute force 
        //Use any sorting algorthim herr T.C and S.C wont be be optimal
        
    //Better Solution 
    
        // function sortZero(arr){
        //     let count0 = 0, count1 = 0, count2 = 0; 
        //     for(let i= 0; i<arr.length; i++){
        //         if(arr[i] == 0) count0++; //3
        //         if(arr[i] == 1) count1++; //5
        //         if(arr[i] == 2) count2++; //2
        //     }
        //     for(let i=0; i<count0; i++) arr[i] = 0;
        //     for(let i=count0; i<count0+count1; i++) arr[i] = 1;
        //     for(let i=count0+count1; i<arr.length; i++) arr[i] = 2;       
        //     return arr;        
        // }
        // console.log(sortZero([0,1,2,0,1,2,0,0,1,1,2,1,0,2,1]))

    //Optimal Solution 
    
        // function sortZero(arr){
        //     let low = 0 , mid = 0, high = arr.length-1;

        //     while(mid <= high){
        //         switch (arr[mid]){
        //             case 0 :
        //                 [arr[low], arr[mid]] = [arr[mid], arr[low]];
        //                 mid++;
        //                 low++;
        //                 break;

        //             case 1:
        //                 mid++;
        //                 break;

        //             case 2:
        //                 [arr[high], arr[mid]] = [arr[mid], arr[high]];
        //                 high--;
        //                 break;

        //             default : 
        //                 console.log("didn't work")
        //         }

        //     }
        //     return arr;
        // }
        // console.log(sortZero([0,1,2,0,1,2,0,0,1,1,2,1,0,2,1]))

//Majority element (>n/2)

    //Brute Force

        // function majority(arr){
        //     for(let i=0; i<arr.length; i++){
        //         let count = 0;

        //         for(let j =0; j<arr.length; j++){
        //             if(arr[i] === arr[j]) count++;
        //         }

        //         if(count > Math.floor(arr.length/2)) return arr[i];
        //     }

        //     return -1;
        // }
        // console.log(majority([0,1,0,0,1,2,0]))

    //Better Solution 

        // function Majority(arr){
        //     const myMap = new Map();
        //     for(let i = 0; i<arr.length; i++){
        //         myMap.set(arr[i], myMap.get(arr[i]) + 1 || 1)
        //     }
        //     for(let i = 0; i< arr.length; i++){
        //         if(myMap.get(arr[i]) > Math.floor(arr.length/2)) return arr[i]
        //     }
        //     return -1;
        // }
        // console.log(Majority([0,1,1,1,1,2,0]))

    //Optimal Solution
        // function Majority(arr){
        //     let count = 0;
        //     let element = null;

        //     for(let i = 0; i<arr.length; i++ ){
        //         if(count === 0){
        //             element = arr[i]
        //         }
        //         count += (arr[i] === element) ? 1 : -1;
        //     }
        //     count = 0;
        //     for(let i =0; i<arr.length; i++){
        //         if(arr[i] === element){
        //             count++;
        //         }
        //     }
        //     if(count > Math.floor(arr.length/2)){
        //         return element;
        //     }
        //     return -1;
        // }
        // console.log(Majority([0,1,0,0,1,2,0]))
        
//Kadane's Algo Maximum sub array sum

    //Brute Force
    // function MaxSumSubArray(arr){
    //         let maxSum = -Infinity;
    //         for(let i= 0; i<arr.length; i++){                                      
    //             for(let j = i; j<arr.length; j++){   
    //                 let sum = 0;  
    //                 for(let k = i; k<=j; k++){
    //                     sum += arr[k];
    //                 }                  
    //                 maxSum = Math.max(maxSum, sum);
    //             }
    //         }
    //         return maxSum;
    //     }

    //Better solution

        // function MaxSumSubArray(arr){
        //     let maxSum = -Infinity;
        //     for(let i= 0; i<arr.length; i++){              
        //         let sum = 0;             
        //         for(let j = i; j<arr.length; j++){                   
        //             sum += arr[j];
        //             maxSum = Math.max(maxSum, sum);
        //         }
        //     }
        //     return maxSum;
        // }
        // console.log(MaxSumSubArray([5,4,-1,7,8]))

    //Optimal Solution Kadane's Algo

    //If asked only sum

        // function MaxSumSubArray(arr){
        //     let maxSum = -Infinity;
        //     let sum = 0;

        //     for(let i=0; i<arr.length; i++){
                
        //         sum += arr[i];

        //         maxSum = Math.max(maxSum, sum);

        //         if(sum < 0) sum = 0;
        //     }
        //     return maxSum;
        //     //if question says that if sum is leeser than 0 then consider an empty array which mean if sum < 0 then take [] empty array as your sub Array and eturn its sum that is 0 .So if(sum < 0) retuen 0;  
        // }
        // console.log(MaxSumSubArray([5,4,-1,7,8]))
        
    //If asked the sub array whose sum is greatest
          
        // function MaxSumSubArray(arr){
        //         let maxSum = -Infinity;
        //         let sum = 0;
        //         let ansStart = -1, ansEnd = -1;
        //         for(let i=0; i<arr.length; i++){
        //             if(sum === 0) start = i;
        //             sum += arr[i];
        //             if(sum > maxSum){
        //                 maxSum = sum;
        //                 ansStart = start;
        //                 ansEnd = i;
        //             }
        //             if(sum < 0) sum = 0;
        //         }             
        //         return arr.slice(ansStart, ansEnd + 1);
        // }
        // console.log(MaxSumSubArray([5,4,-1,7,8]));

//Best time buy and sell stock

        // function BestBuySell(arr){
        //     let min = arr[0], profit = 0;

        //     for(let i = 0; i<arr.length; i++){
        //         let cost = arr[i] - min;
        //         profit = Math.max(profit, cost);
        //         min = Math.min(min, arr[i]);
        //     }
        //     return profit;
        // }
        // console.log(BestBuySell([7,1,5,3,6,4]))

//Rearrange elements based on sign
    
    //Brute Force

        // function Rearrange(arr){
        //     let arrPositive = [], arrNegative = [];

        //     for(let i = 0; i<arr.length; i++){
        //         if(arr[i] < 0){
        //             arrNegative.push(arr[i]);
        //         }
        //         if(arr[i] >= 0){
        //             arrPositive.push(arr[i]);
        //         }
        //     }

        //     for(let i = 0; i<arr.length/2; i++){
        //         arr[2*i] = arrPositive[i];
        //         arr[2*i + 1] = arrNegative[i];
        //     }

        //     return arr;
        // }
        
        // console.log(Rearrange([-1,2,-2,-3,5,8,-1,-2,2,4]))

    //optimal for array having equal number of positives and negatives

        // function Rearrange(arr){

        //     let arrPositive = 0, arrNegative = 1;
        //     let arrNew = [];

        //     for(let i = 0; i<arr.length; i++){

        //         if(arr[i] < 0){
        //             arrNew[arrNegative] = arr[i];
        //             arrNegative += 2;
        //         }else{
        //             arrNew[arrPositive] = arr[i];
        //             arrPositive += 2;
        //         }

        //     }
        //     return arrNew;
        // }
        
        // console.log(Rearrange([-1,2,-2,-3,5,8,-1,-2,2,4]));

    //opti  for array having unequal number of positives and negatives

        // function Rearrange(arr){
        //     let arrPositive = [], arrNegative = [];

        //     for(let i = 0; i<arr.length; i++){
        //         if(arr[i] < 0){
        //             arrNegative.push(arr[i]);
        //         }
        //         if(arr[i] >= 0){
        //             arrPositive.push(arr[i]);
        //         }
        //     }

        //     if(arrPositive.length > arrNegative.length){
        //         for(let i =0; i<arrNegative.length; i++){
        //             arr[2*i] = arrPositive[i];
        //             arr[2*i + 1] = arrNegative[i]
        //         }

        //         let index = arrNegative.length*2;
        //         for(let i = arrNegative.length; i<arrPositive.length; i++){
        //             arr[index] = arrPositive[i];
        //             index++;
        //         }
        //     }else{
        //         for(let i =0; i<arrPositive.length; i++){
        //             arr[2*i] = arrPositive[i];
        //             arr[2*i +1] = arrNegative[i]
        //         }

        //         let index = arrPositive.length*2;
        //         for(let i = arrPositive.length; i<arrNegative.length; i++){
        //             arr[index] = arrNegative[i];
        //             index++;
        //         }
        //     }
        //     return arr
        // }
        // console.log(Rearrange([-1,2,-2,-3,5,8,-1,-2,2,-4]));

//Next permutation

    //Optimal Solution

        // function nextPermutation(arr){
        //     let index = -1;
        //     let n = arr.length;
            
        //     for (let i = n-2; i >= 0; i-- ){
        //         if(arr[i] < arr[i+1]){
        //             index =i;
        //             break;
        //         }
                
        //     }

        //     if(index == -1){
        //        return arr.reverse();
        //     }

        //     for(let i = n-1; i>index; i--){
        //         if(arr[i] > arr[index]){
        //             [arr[index], arr[i]] = [arr[i], arr[index]]
        //             break;
        //         }
               
        //     }

        //     function reverse(arr, start, end){
        //         while(start < end){
        //             [arr[start], arr[end]] = [arr[end], arr[start]]
        //             start++;
        //             end--;
        //         }
        //         return arr;
        //     }
            
        //     return reverse(arr, index+1, n-1);
        // }
    
        // console.log(nextPermutation([2,1,5,4,3,0,0]))

//Leaders in an array

    //Brute Force
        // function leader(arr){
        //     let leader = true;
        //     let leaders = [];
        //     for(let i=0; i< arr.length; i++){
        //         leader = true;
        //         for(let j = i+1; j<arr.length; j++){
        //             if(arr[j] > arr[i]){
        //                 leader = false;
        //                 break;
        //             }
        //         }
        //         if(leader === true){
        //             leaders.push(arr[i]);
        //         }
        //     }
        //     return leaders;
        // }

    //Optimal Solution
    //         function leader(arr){
    //             let max = -Infinity;
    //             let ans = [];

    //             let n = arr.length;

    //             for(let i = n-1; i>= 0; i--){
    //                 if(arr[i] > max){
    //                     ans.push(arr[i]);
    //                     max = arr[i];
    //                 }
    //             }

    //             ans.reverse();

    //             return ans
    //         }
    // console.log(leader([10, 22, 12, 3, 0,6]))

//Longest Consecutive Sequence

    //Brute force
        // function LongestSequence(arr){
        //     if(arr.length === 0) return 0;
        //     let longest = 1;
        //     let n = arr.length;

        //     for(let i = 0; i<n; i++){
        //         let count = 1;
        //         let element = arr[i];
        //         for (let j = 0; j<n; j++){
        //             if(arr[j] === element + 1) {
        //                 element = arr[j];
        //                 count++;
        //                 j= -1;
        //             }
        //         }
        //         //console.log(count);
        //         longest = Math.max(longest, count);
        //     }

        //     return longest;
        // }
        //console.log(LongestSequence([102,4,100,1,101,3,2,1,1]))

    //Better SOlution

        // function LongestSequence(arr){
        //     if(arr.length === 0) return 0;
        //     let longest = 1;
        //     let lastSmaller = -Infinity;
        //     let count = 0;
            
        //     arr.sort((a,b)=> a - b);

        //     for(let i = 0; i<arr.length; i++){
        //         if(arr[i] - 1 == lastSmaller){
        //             count += 1;
        //             lastSmaller = arr[i]
        //         }else if(arr[i] != lastSmaller){
        //             count = 1;
        //             lastSmaller = arr[i];
        //         }

        //         longest = Math.max(longest, count);
        //     }
        //     return longest;
        // }
        // console.log(LongestSequence([102,4,100,1,101,3,2,1,1]))

    //Optimal solution

        // function LongestSequence(arr){
        //     if(arr.length === 0) return 0;

        //     let mySet = new Set(arr);
        //     let longest = 1;

        //     for(let element of mySet){
        //         if(!mySet.has(element - 1)){
        //             let currentElement = element;
        //             let count = 1

        //             while(mySet.has(currentElement + 1)){
        //                 currentElement++;
        //                 count++
        //             }

        //             longest = Math.max(longest, count);
        //         }
        //     }

        //     return longest;
        // }
        // console.log(LongestSequence([102,4,100,1,101,3,2,1,1]));

//Number of subarrays whose sum is k

    //Brute force
    // function NumberOfSubarrayWithSum_k(arr, n){
    //         let count = 0;
    //         for(let i =0; i<arr.length; i++){
                
    //             for(let j =i; j<arr.length; j++){
    //                 let sum = 0;
    //                 for(let k; k<=j; k++){
    //                     sum += arr[k];
    //                 }       
    //                 if(sum === n) {
    //                     count++;
    //                 }
    //             }
    //         }
    //         return count;
    //     }
    //     console.log(NumberOfSubarrayWithSum_k([1,1,2,3,4,4,5,6,6], 3))

    // //Better solution
    //     function NumberOfSubarrayWithSum_k(arr, n){
    //        let count = 0;
    //         for(let i =0; i<arr.length; i++){
    //             let sum = 0;
    //             for(let j =i; j<arr.length; j++){
    //                 sum += arr[j];
                    
    //                 if(sum === n) {
    //                     count++;
    //                 }
    //             }
    //         }
    //         return count;
    //     }
    //     console.log(NumberOfSubarrayWithSum_k([1,1,2,3,4,4,5,6,6], 4))

    //Optimal Solution

        // function NumberOfSubarrayWithSum_k(arr, n) {
        //     let myMap = new Map();
        //     let count = 0, sum = 0;
        //     myMap.set(0, 1);
            
        //     for(let i = 0; i < arr.length; i++) {
        //         sum += arr[i];
        //         let remaining = sum - n;
        //         count += myMap.get(remaining) || 0;
        //         //remaining is not present then returned count will be 0 no increase in the total count

        //         myMap.set(sum, myMap.get(sum) + 1 || 1)
        //     }
        //     return count;
        // }
        // console.log(NumberOfSubarrayWithSum_k([1,1,2,3,4,4,5,6,6], 3))

//majority element n/3 times

    //Brute force
        // function MajorityScond(arr) {
        //     let resultArray = [];

        //     for(let i = 0; i < arr.length; i++) {

        //         if(resultArray.length == 0 || resultArray[0] !== arr[i]) {
        //             let count = 0;

        //             for(let j = 0; j < arr.length; j++) {    
        //                     if(arr[j] === arr[i]) {
        //                         count++;
        //                     }
        //             }
        //             if(count > Math.floor(arr.length / 3)) {
        //                 resultArray.push(arr[i]);
        //             } 
        //         }

        //         if(resultArray.length === 2) break;
        //     }

        //     return resultArray;
        // } 
        
        // console.log(MajorityScond([1,1,1,2,2,2,3,3]));

    //Better solution

        // function MajorityScond(arr) {
        //     let myMap = new Map();
        //     let min = Math.floor(arr.length/3) + 1;
        //     let resultArray = []

        //     for(let i = 0; i < arr.length; i++) {
        //         myMap.set(arr[i], myMap.get(arr[i]) + 1 || 1);
        //         if(myMap.get(arr[i]) == min) {
        //             resultArray.push(arr[i]);
        //         }
                
        //         if(resultArray.length == 2) break;
        //     }
        //     return resultArray;
        // }
        // console.log(MajorityScond([1,1,1,2,2,2,3,3]));

    //Optimal Solution

        // function Majority(arr){
        //     let condidate1 = null;
        //     let condidate2 = null;
        //     let count1 = 0, count2 = 0;

        //     for(let num of arr) {
        //         if(num === condidate1) count1++;
        //         else if (num === condidate2) count2++;
        //         else if (count1 === 0) {
        //             condidate1 = num;
        //             count1 = 1;
        //         } else if (count2 === 0) {
        //             condidate2 = num;
        //             count2 = 1;
        //         } else {
        //             count1--;
        //             count2--;
        //         }
        //     }

        //     count1 = 0;
        //     count2 = 0;

        //     for(let num of arr) {
        //         if(num === condidate1) {
        //             count1++;
        //         } else if (num === condidate2) {
        //             count2++;
        //         }
                 
        //     }

        //     let result = [];
        //     let n = arr.length;

        //     if(count1 > Math.floor(n/3)) {
        //         result.push(condidate1)
        //     }
        //     if(count2 > Math.floor(n/3)) {
        //         result.push(condidate2);
        //     }

        //     return result;
        // }
        // console.log(Majority([1,1,1,2,2,2,3,3]))

//3 Sum Problem

    //Brute force

        // function triplet(arr) {
        //     if(arr.length === 0) return [];

        //     let n = arr.length;
        //     let mySet = new Set();

        //     for(let i = 0; i < n; i++) {
        //         for(let j = i + 1; j < n; j++) {

        //             for(let k = j + 1; k < n; k++) {
        //                 if(arr[i] + arr[j] + arr[k] === 0) {
        //                     let triplate = [arr[i], arr[j], arr[k]].sort((a,b) => a - b).toString();
        //                     if(!mySet.has(triplate)) {
        //                         mySet.add(triplate);
        //                     }
        //                 }
        //             }
        //         }
        //     }

        //     let result = [];

        //     for(let str of mySet) {
        //         result.push(str.split(',').map(Number))
        //          //map(Number) to convert the elements back to number because with toString() on an array converts the whole array including its elements to string
        //     }
        //     return result;
        // }
        // console.log(triplet([-1, 0, 1, 2, -1, -4]))

    //Better appraoch

    //     function triplateSum1(arr) {
    //         if(arr.length === 0) return [];
    //         let mySet = new Set();

    //         for(let i = 0; i < arr.length; i++) {
    //             let pickSet = new Set();

    //             for(let j = i + 1; j < arr.length; j++) {
    //                 let third = -(arr[i] + arr[j]);

    //                 if(pickSet.has(third)) {
    //                     let triplate = [arr[i], arr[j], third].sort((a,b) => a - b).toString();
    //                     if(!mySet.has(triplate)) {
    //                         mySet.add(triplate);
    //                     }
    //                 }

    //                 pickSet.add(arr[j]);
    //             }
    //         }
    //         let result = [];

    //         for(let str of mySet) {
    //             result.push(str.split(',').map(num => Number(num)));
    //         }

    //         return result;
    //     }
            
    //      console.log(triplateSum1([-1, 0, 1, 2, -1, -4]))  

    // //Optimal Approach

    //     function triplateSum(arr) {
    //         if (arr.length === 0) return [];

    //         let n = arr.length;
    //         let result = [];
    //         arr.sort((a,b) => a - b);

    //         for (let i = 0; i < n; i++) {
    //              // Skip duplicates for i
    //             if(i > 0 && arr[i] === arr[i - 1]) continue;
    //             //checked i > 0 so that i - 1 dont give error

    //             let j = i + 1;
    //             let k = n - 1;

    //             while (j < k) {
    //                 let sum = arr[i] + arr[j] + arr[k];
                    
    //                 if (sum < 0) j++;
    //                 else if (sum > 0) k--;
    //                 else {
    //                     result.push([arr[i] , arr[j], arr[k]]);
    //                     j++;
    //                     k--;

    //                     // Skip duplicates for j and k
    //                     while (j < k && arr[j] === arr[j - 1]) j++; //j < k as we dont wnat it to go out of bound
    //                     while (k > j && arr[k] === arr[k + 1]) k--;
    //                 }
    //             }
    //         }
    //         return result;
    //     }
    //     console.log(triplateSum([-1, 0, 1, 2, -1, -4])) 

//Largest subArray with sum 0

    //brute Force

        // function maxSubarrayWithZeroSum(arr) {
        //     if(arr.length === 0) return 0;
        //     let n = arr.length;
        //     let len = 0;
            
        //     for(let i = 0; i < n; i++) {
        //         for(let j = i; j < n; j++) {
        //             let sum = 0;

        //             for(let k = i; k <= j; k++) {
        //                 sum += arr[k]; //jis loop me count karte hain usi loop me sum var initialize nahi karte
        //             }

        //             if(sum === 0) {
        //                 len = Math.max(len , (j - i + 1));
        //             }
        //          }
        //     }
        //     return len;
        // }    
        // console.log(maxSubarrayWithZeroSum([15,-2,2,-8,1,7,10,23]))

    //Better solution

        // function maxSubarrayWithZeroSum(arr) {
        //         if(arr.length === 0) return 0;
        //         let n = arr.length;
        //         let len = 0;
                
        //         for(let i = 0; i < n; i++) {
        //             let sum = 0;

        //             for(let j = i; j < n; j++) {
                        
        //                 sum += arr[j]; //jis loop me count karte hain usi loop me sum var initialize nahi karte
            
        //                 if(sum === 0) {
        //                     len = Math.max(len , (j - i + 1));
        //                 }
        //              }
        //         }
        //         return len;
        //     }    
        // console.log(maxSubarrayWithZeroSum([15,-2,2,-8,1,7,10,23])) 

//Optimal soluttion

        // function maxSubarrayWithZeroSum(arr) {
        //     if (arr.length === 0) return 0;
        //     let sum = 0;
        //     let n = arr.length;
        //     let len = 0;
        //     let myMap = new Map;

        //     for (let i = 0; i < n; i++) {
        //         sum += arr[i];

        //         if (sum === 0) {
        //             len = i + 1;
        //         } else if (myMap.has(sum)) {
        //             len = Math.max(len, i - myMap.get(sum));
        //         } else {
        //             myMap.set(sum , i);
        //         }
        //     }

        //     return len;

        // }
        // console.log(maxSubarrayWithZeroSum([1,-1,3,2,-2,-8,1,7,10,23]))

//Merging overlapping interval

    //Brute Force
    
    //     function mergeIntervals(arr) {
    //         let n = arr.length;
            
    //         if (n === 0) return [];
    //         let ans = [];

    //         arr.sort((a,b) => {
    //             if (a[0] === b[0]) {
    //                 return a[1] - b[1];
    //             } else {
    //                 return a[0] - b[0];
    //             }
    //         })

    //         for(let i = 0; i < n; i++) {
    //             let start = arr[i][0];
    //             let end = arr[i][1];

    //             if (ans.length !== 0 && end <= ans[ans.length - 1][1]) continue;

    //             for(let j = i + 1; j < n; j++) {
    //                 if(arr[j][0] <= end) {
    //                     end = Math.max(end, arr[j][1]);
    //                 } else {
    //                     break;
    //                 }
    //             }
    //             ans.push([start, end]);
    //             // console.log(ans)
    //         }
            
    //         return ans;
    //     }

    //     console.log(mergeIntervals([[1,3], [2,6], [8,9], [9,11], [8,10], [2,4], [15,18], [16,17]]))

    // //Optimal solution

    // function mergeIntervals1(arr) {
    //         let n = arr.length;
            
    //         if (n === 0) return [];
    //         let ans = [];

    //         arr.sort((a,b) => {
    //             if (a[0] === b[0]) {
    //                 return a[1] - b[1];
    //             } else {
    //                 return a[0] - b[0];
    //             }
    //         })

    //         for(let i = 0; i < n; i++) {     

    //             if (ans.length == 0 || arr[i][0] > ans[ans.length - 1][1]) {
    //                 ans.push(arr[i]);
    //             } else {
    //                 ans[ans.length - 1][1] = Math.max(ans[ans.length - 1][1], arr[i][1]);
    //             }
    //         }
            
    //         return ans;
    //     }

    //     console.log(mergeIntervals1([[1,3], [2,6], [8,9], [9,11], [8,10], [2,4], [15,18], [16,17]]))

//Merging two sorted arrays returning the two given arrays after element redistribution between the two array based on order of elements in real

    //Brute force

        // function mergeSorted(arr1, n, arr2, m) {
        //     if (n === 0 && m === 0) return [];

        //     let thirdArray = new Array(n + m);

        //     let left = 0;
        //     let right = 0;
        //     let index = 0;

        //     while(left < n && right < m) {

        //         if(arr1[left] <= arr2[right]) {
        //             thirdArray[index] = arr1[left];
        //             left++; index++;
        //         } else {
        //             thirdArray[index] = arr2[right];
        //             right++; index++;
        //         }
        //     }

        //     while (left < n) {
        //         thirdArray[index] = arr1[left];
        //         left++; index++;
        //     }

        //     while (right < m) {
        //         thirdArray[index] = arr2[right];
        //         right++; index++;
        //     }

        //     for (let i = 0; i < m + n; i++) {
        //         if (i < n) {
        //             arr1[i] = thirdArray[i];
        //         } else {
        //             arr2[i - n] = thirdArray[i]
        //         }
        //     }

        // }
        
        // let arr1a = [0,2,5,8,9];
        // let arr2b = [1,3,4,6,10];

        // mergeSorted(arr1a, 5, arr2b, 5)
        // console.log(arr1a);
        // console.log(arr2b);

    //Optimal One

        // function mergeSorted(arr1, m, arr2, n) {
        //     let left = m - 1;;
        //     let right = 0;

        //     while (left < m, right < n) {
        //         if (arr1[left] > arr2[right]) {
        //             [arr1[left], arr2[right]] = [arr2[right], arr1[left]];
        //             left--; 
        //             right++;
        //         } else {
        //             break;
        //         }
        //     }

        //     arr1.sort((a,b) => a - b);
        //     arr2.sort((a,b) => a - b);

        // }
        // let arr1a = [0,2,5,8,9];
        // let arr2b = [1,3,4,6,10];

        // mergeSorted(arr1a, 5, arr2b, 5)
        // console.log(arr1a);
        // console.log(arr2b);


//gggg
        // function mergeSorted(arr1, m, arr2, n) {

        //     for (let i = 0; i < n; i++) {
        //         arr1[m + i] = arr2[i]
        //     }

        //     arr1.sort((a,b) => a - b);
        //     return arr1;
        // }
        // let arr1a = [0,2,5,0,0,0];
        // let arr2b = [1,3,4];

        // console.log(mergeSorted(arr1a, 3, arr2b, 3));
        
    //optimal solution

        // function mergeSorted(arr1, m, arr2, n) {
        //     let left = m - 1;
        //     let right = n - 1;
        //     let position = m + n - 1;

        //     while (left >= 0 && right >= 0) {
        //         if (arr2[right] >= arr1[left]) {
        //             arr1[position--] = arr2[right--]; //j th element is placed thus we are decrementing it by post decrement mean it'll return the current value first then it'll decrement
        //            // right--, position--;
        //         } else {
        //             arr1[position--] = arr1[left--];
        //            // left--, position--;
        //         }
        //     }

        //     while (right >= 0) {
        //         arr1[position--] = arr2[right--];
        //         //right--, position--;
        //     }

        //     return arr1;
        // }

        // let arr1a = [0,2,5,0,0,0];
        // let arr2b = [1,3,4];

        // console.log(mergeSorted(arr1a, 3, arr2b, 3));

//Subarray with max product

    //Brute Force

    //    function maxProductSubarray1(arr) {
    //     if (arr.length === 0) return [];

    //     let n = arr.length;
    //     let maxProduct = -Infinity;  //because product of subarray can be -ve because array has -ve elements too so this should be ass minimum as possible so that we can get the product result in this as it lowest of all so when compared it will get next value as that will be always greater than this.

    //     for(let i = 0; i < n; i++) {
    //         for(let j = i; j < n; j++) {
    //             let product = 1;

    //             for(let k = i; k <= j; k++) {

    //                 product *= arr[k];
    //             }
                
    //             maxProduct = Math.max(maxProduct, product);
    //         }
    //     }
        
    //     return maxProduct;

    //    } 

    //    console.log(maxProductSubarray1([-2,0,-1]));

    //Better approach 

        // function maxProductSubarray2(arr) {
        //     if (arr.length === 0) return [];

        //     let n = arr.length;
        //     let maxProduct = -Infinity; 

        //     for(let i = 0; i < n; i++) {
        //         let product = 1;

        //         for(let j = i; j < n; j++) {
        //              product *= arr[j];
        //              maxProduct = Math.max(maxProduct, product);

        //              //we have pust max assignment inside because at each iteration we are getting a new subarray and we need to examin its product , if we check outsie this loop the product will be examined when loop will end at that time we will have product of the last sub array of i and we have lost the  products of all intermediat subarrays.
        //         }          
        //     }      
        //     return maxProduct;

        // } 
 
        // console.log(maxProductSubarray2([-2,0,-1]));

    //Optimal solution 

    // function maxProductSubarray3(arr) {
    //         if (arr.length === 0) return [];

    //         let n = arr.length;
    //         let maxProduct = -Infinity;  
    //         let suffixProduct = 1;
    //         let prefixProduct = 1;

    //         for (let i = 0; i < n; i++) {
    //             if (suffixProduct == 0) suffixProduct = 1;
    //             if (prefixProduct == 0) prefixProduct =1;

    //             suffixProduct *= arr[i];
    //             prefixProduct *= arr[n-1-i];

    //             maxProduct = Math.max(maxProduct, Math.max(suffixProduct, prefixProduct));
    //         }      
    //         return maxProduct;
    //     } 

    //     console.log(maxProductSubarray3([-2,0,-1])); 
        
//Container with most water

    //Brute force
    
        function mostWater1(arr) {
            if (arr.length === 0) return  0;
             
            let n = arr.length;
            let maxArea = 0;

            for (let i = 0; i < n; i++) {
                for(let j = i + 1; j < n; j++) {
                    let area = Math.min(arr[i], arr[j]) * (j - i);

                    maxArea = Math.max(maxArea, area);
                }
            }
            return maxArea;
        }

        console.log(mostWater1([3, 1, 2, 4, 5]));

    //Optimal Solution

        function mostWater2(arr) {
            if (arr.length === 0) return 0;

            let n = arr.length;
            let maxArea = 0;
            let left = 0;
            let right = n-1;

            while (left < right) {
                let temp = Math.min(arr[left], arr[right]) * (right - left);
                maxArea = Math.max(maxArea, temp);

                if (arr[left] < arr[right]) {
                    left++;
                } else {
                    right--;
                }
            }

            return maxArea;
        }

        console.log(mostWater2([3, 1, 2, 4, 5]));
    </script>
</body>

</html>